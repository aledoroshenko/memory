{"version":3,"sources":["config.ts","get-images-for-cards.ts","initial-state.ts","reducer.ts","Result.tsx","Card.tsx","Board.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["config","imagesByTheme","cats","covers","tiles","cards","rawCards","availableRawCards","boardSize","uniqueCards","Array","from","length","flatMap","_","i","sort","Math","random","getRawCards","map","tileUrl","id","uuid","frontUrl","backUrl","rawCard","isFlipped","isMatch","matchId","initialState","moves","cardsByIds","reduce","memo","card","flippedCardsIds","flipSoon","allFlipped","matchedCards","roundDuration","roundStart","reducer","state","action","type","cardId","Date","data","currentCardId","currentCardMatchId","isEnoughCardsToMatch","currentMatchedCards","updatedCard","flipCard","every","flippedCardId","forEach","Object","values","intervalToDuration","start","end","StyledResultDetails","styled","div","ResultDetails","onClose","cardsAmount","formatDuration","onClick","Wrapper","Result","fullSizeStyle","css","absoluteFullSizeStyle","cardStyle","url","StyledCard","CardBack","angle","CardFront","getRandomAngle","min","max","Card","angleFront","useRef","current","angleBack","BoardSection","StyledBoard","Board","onCardFlip","flipCardsBack","useEffect","setTimeout","key","AppShell","Flex","Intro","GlobalStyle","createGlobalStyle","App","useReducer","dispatch","useCallback","Fragment","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.ee32f0f2.chunk.js","sourcesContent":["export const config = {\n  size: 12,\n  uniqueCardsAmount: 2,\n  theme: \"cats\",\n  difficultyLevels: {\n    EASY: { cardsAmount: 6 },\n    MEDIUM: { cardsAmount: 12 },\n    HARD: { cardsAmount: 16 },\n  },\n};\n","// We should get the list of available files by theme\n\ntype TImagePath = string;\n\ntype TImagesByTheme = {\n  [TThemeName: string]: {\n    covers: TImagePath[];\n    tiles: TImagePath[];\n  };\n};\n\nexport const imagesByTheme: TImagesByTheme = {\n  cats: {\n    covers: [\"/tiles/cats/covers/1.png\"],\n    tiles: [\n      \"/tiles/cats/tiles/1.png\",\n      \"/tiles/cats/tiles/2.png\",\n      \"/tiles/cats/tiles/3.png\",\n      \"/tiles/cats/tiles/4.png\",\n      \"/tiles/cats/tiles/5.png\",\n      \"/tiles/cats/tiles/6.png\",\n      \"/tiles/cats/tiles/7.png\",\n      \"/tiles/cats/tiles/8.png\",\n      \"/tiles/cats/tiles/9.png\",\n      \"/tiles/cats/tiles/10.png\",\n      \"/tiles/cats/tiles/11.png\",\n      \"/tiles/cats/tiles/12.png\",\n      \"/tiles/cats/tiles/13.png\",\n      \"/tiles/cats/tiles/14.png\",\n      \"/tiles/cats/tiles/15.png\",\n    ],\n  },\n};\n","import { v4 as uuid } from \"uuid\";\nimport { TCard, TRawCard } from \"./types\";\nimport { config } from \"./config\";\nimport { imagesByTheme } from \"./get-images-for-cards\";\n\n// Form somewhere else collection of fronts and backs\nexport const availableRawCards = imagesByTheme[config.theme].tiles\n  .map((tileUrl) => ({\n    id: uuid(),\n    frontUrl: tileUrl,\n    backUrl: imagesByTheme[config.theme].covers[0],\n  }))\n  .sort(() => Math.random() - 0.5);\n\nfunction getRawCards(\n  availableRawCards: TRawCard[],\n  boardSize: number,\n  uniqueCards: number\n) {\n  return Array.from({ length: boardSize / uniqueCards })\n    .flatMap((_, i) =>\n      Array.from({ length: uniqueCards }, () => availableRawCards[i])\n    )\n    .sort(() => Math.random() - 0.5);\n}\n\nfunction normalizeCards(cards: TCard[]): { [key: string]: TCard } {\n  return cards.reduce((memo, card) => {\n    return { ...memo, [card.id]: card };\n  }, {});\n}\n\nfunction prepareCardsForBoard(rawCards: TRawCard[]): TCard[] {\n  return rawCards.map((rawCard: TRawCard) => ({\n    id: uuid(),\n    isFlipped: false,\n    isMatch: false,\n    matchId: rawCard.id,\n    frontUrl: rawCard.frontUrl,\n    backUrl: rawCard.backUrl,\n  }));\n}\n\nconst rawCards = getRawCards(\n  availableRawCards,\n  config.size,\n  config.uniqueCardsAmount\n);\n\nconst cards = prepareCardsForBoard(rawCards);\n\nexport const initialState = {\n  moves: 0,\n  cardsByIds: normalizeCards(cards),\n  flippedCardsIds: [],\n  flipSoon: false,\n  allFlipped: false,\n  matchedCards: 0,\n  roundDuration: null,\n};\n","import intervalToDuration from \"date-fns/intervalToDuration\";\n\nimport { TAppAction, TAppState, TCard } from \"./types\";\nimport { config } from \"./config\";\nimport { initialState } from \"./initial-state\";\n\nfunction flipCard(card: TCard): TCard {\n  const updatedCard = { ...card };\n  updatedCard.isFlipped = !card.isFlipped;\n\n  return updatedCard;\n}\n\nlet roundStart: null | Date = null;\n\nexport const reducer = (state: TAppState, action: TAppAction): TAppState => {\n  switch (action.type) {\n    case \"RESTART\":\n      return { ...initialState };\n\n    case \"FLIP_SOON\":\n      state.flippedCardsIds.map(\n        (cardId) => (state.cardsByIds[cardId].isFlipped = false)\n      );\n\n      return {\n        ...state,\n        cardsByIds: { ...state.cardsByIds },\n        flippedCardsIds: [],\n        flipSoon: false,\n      };\n\n    case \"FLIP_CARD\":\n      if (state.moves === 0) {\n        roundStart = new Date();\n      }\n\n      const { id: currentCardId, matchId: currentCardMatchId } = action.data;\n      const moves = state.moves + 1;\n      let flippedCardsIds = [...state.flippedCardsIds, currentCardId];\n      const isEnoughCardsToMatch =\n        flippedCardsIds.length === config.uniqueCardsAmount;\n      let flipSoon = false;\n      let currentMatchedCards = state.matchedCards;\n      let roundDuration = null;\n\n      const updatedCard = flipCard(state.cardsByIds[currentCardId]);\n\n      if (isEnoughCardsToMatch) {\n        const hasMatch = flippedCardsIds.every(\n          (flippedCardId) =>\n            state.cardsByIds[flippedCardId].matchId === currentCardMatchId\n        );\n\n        if (hasMatch) {\n          updatedCard.isMatch = true;\n\n          flippedCardsIds.forEach((cardId) => {\n            state.cardsByIds[cardId] = {\n              ...state.cardsByIds[cardId],\n              isMatch: true,\n            };\n          });\n\n          currentMatchedCards = currentMatchedCards + flippedCardsIds.length;\n\n          flippedCardsIds = [];\n        } else {\n          flipSoon = true;\n        }\n      }\n\n      const allFlipped =\n        currentMatchedCards === Object.values(state.cardsByIds).length;\n\n      if (allFlipped && roundStart !== null) {\n        roundDuration = intervalToDuration({\n          start: roundStart,\n          end: new Date(),\n        });\n      }\n\n      return {\n        ...state,\n        moves,\n        cardsByIds: {\n          ...state.cardsByIds,\n          [currentCardId]: updatedCard,\n        },\n        flippedCardsIds,\n        flipSoon,\n        allFlipped: allFlipped,\n        matchedCards: currentMatchedCards,\n        roundDuration,\n      };\n\n    default:\n      return state;\n  }\n};\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport formatDuration from \"date-fns/formatDuration\";\n\nconst StyledResultDetails = styled.div`\n  max-width: 500px;\n  min-height: 100px;\n  background-color: #fff;\n  padding: 10px 40px 60px;\n`;\n\ntype ResultProps = {\n  data: {\n    roundDuration: null | Duration;\n    cardsAmount: number;\n    moves: number;\n  };\n  onClose: () => void;\n};\n\nconst ResultDetails = ({ data, onClose }: ResultProps) => {\n  return (\n    <StyledResultDetails>\n      <h2>You have some memory</h2>\n      <p>\n        You solve round with <strong>{data.cardsAmount} cards</strong> with{\" \"}\n        <strong>{data.moves} moves</strong> and{\" \"}\n        <strong>\n          spend {data.roundDuration && formatDuration(data.roundDuration)}\n        </strong>\n        .\n      </p>\n\n      <button onClick={onClose}>Try again</button>\n    </StyledResultDetails>\n  );\n};\n\nconst Wrapper = styled.div`\n  position: absolute;\n  top: 0;\n  right: 0;\n  left: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 0.3);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n`;\n\nexport const Result = ({ data, onClose }: ResultProps) => {\n  return (\n    <Wrapper>\n      <ResultDetails data={data} onClose={onClose} />\n    </Wrapper>\n  );\n};\n","import React, { useRef } from \"react\";\nimport styled, { css } from \"styled-components\";\nimport { TCard } from \"./types\";\n\nconst fullSizeStyle = css`\n  width: 100%;\n  height: 100%;\n`;\n\nconst absoluteFullSizeStyle = css`\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n`;\n\nconst cardStyle = css<TCardSideProps>`\n  backface-visibility: hidden;\n  box-shadow: 0 0 3px 0 rgba(0, 0, 0, 0.2);\n  ${({ url }) => `background: #fff url(\".${url}\") no-repeat center center;`};\n  border: 1px solid aliceblue;\n  background-size: cover;\n`;\n\nconst Wrapper = styled.div`\n  ${fullSizeStyle};\n  transform-style: preserve-3d;\n  transition: 0.3s transform;\n\n  &:active {\n    transform: scale(0.875);\n  }\n`;\n\nconst StyledCard = styled.div<TStyledCardProps>`\n  position: relative;\n  ${fullSizeStyle};\n  ${({ isFlipped }) =>\n    isFlipped &&\n    css`\n      ${Wrapper} {\n        transform: rotateX(-180deg) rotateZ(5deg);\n      }\n    `};\n`;\n\nconst CardBack = styled.div<TCardSideProps>`\n  ${cardStyle};\n  ${fullSizeStyle};\n  ${({ angle }) => `transform: rotateZ(${angle})`};\n`;\n\nconst CardFront = styled.div<TCardSideProps>`\n  ${cardStyle};\n  ${absoluteFullSizeStyle};\n  ${({ angle }) => `transform: rotateX(-180deg) rotateZ(${angle})`};\n`;\n\ntype TCardProps = {\n  data: TCard;\n  onClick: () => void;\n};\n\ntype TStyledCardProps = {\n  isFlipped: boolean;\n};\n\ntype TCardSideProps = {\n  url: string;\n  angle: string;\n};\n\nfunction getRandomAngle(min: number, max: number) {\n  return `${Math.random() * (max - min) + min}deg`;\n}\n\nexport const Card = ({ data, onClick }: TCardProps) => {\n  const { current: angleFront } = useRef(getRandomAngle(-3, 3));\n  const { current: angleBack } = useRef(getRandomAngle(-3, 3));\n\n  return (\n    <StyledCard isFlipped={data.isFlipped}>\n      <Wrapper>\n        <CardFront angle={angleFront} url={data.frontUrl} />\n        <CardBack onClick={onClick} angle={angleBack} url={data.backUrl} />\n      </Wrapper>\n    </StyledCard>\n  );\n};\n","import { TCard } from \"./types\";\nimport { Card } from \"./Card\";\nimport React, { useEffect } from \"react\";\nimport styled from \"styled-components\";\n\nconst BoardSection = styled.div`\n  flex: 0 0 25%;\n  display: flex;\n  height: auto;\n  justify-content: center;\n  align-items: stretch;\n\n  &:before {\n    content: \"\";\n    display: table;\n    padding-top: 100%;\n  }\n`;\n\nconst StyledBoard = styled.div`\n  width: 800px;\n  display: flex;\n  justify-content: start;\n  flex-wrap: wrap;\n`;\n\ntype TBoardProps = {\n  flipSoon: boolean;\n  cards: TCard[];\n  onCardFlip: (card: TCard) => void;\n  flipCardsBack: () => void;\n};\n\nexport const Board = ({\n  flipSoon,\n  cards,\n  onCardFlip,\n  flipCardsBack,\n}: TBoardProps) => {\n  useEffect(() => {\n    if (flipSoon) {\n      setTimeout(() => {\n        flipCardsBack();\n      }, 1000);\n    }\n  }, [flipSoon, flipCardsBack]);\n\n  return (\n    <StyledBoard>\n      {cards.map((card: TCard) => (\n        <BoardSection key={card.id}>\n          <Card data={card} onClick={() => onCardFlip(card)} />\n        </BoardSection>\n      ))}\n    </StyledBoard>\n  );\n};\n","import React, { useCallback, useReducer } from \"react\";\nimport styled, { createGlobalStyle } from \"styled-components\";\nimport { reducer } from \"./reducer\";\nimport { TCard } from \"./types\";\nimport { initialState } from \"./initial-state\";\nimport { Result } from \"./Result\";\nimport { config } from \"./config\";\nimport { Board } from \"./Board\";\n\nconst AppShell = styled.div`\n  display: flex;\n  width: 100%;\n  justify-content: center;\n  flex-direction: column;\n`;\n\nconst Flex = styled.div`\n  width: 100%;\n  display: flex;\n  justify-content: center;\n`;\n\nconst Intro = styled.div`\n  text-align: center;\n  margin-top: 30px;\n  margin-bottom: 30px;\n\n  max-width: 600px;\n\n  h1 {\n    margin-bottom: 0;\n  }\n\n  p {\n    margin: 10px;\n  }\n`;\n\nconst GlobalStyle = createGlobalStyle`\n  body {\n    background-color: #e2e8ea;\n  }\n`;\n\nfunction App() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const restartGame = () => {\n    dispatch({ type: \"RESTART\" });\n  };\n\n  // UseCallback because we pass it to useEffect\n  const flipCardsBack = useCallback(() => {\n    dispatch({ type: \"FLIP_SOON\" });\n  }, []);\n\n  const flipCard = (card: TCard) => {\n    // Waiting for reset, don't accept clicks\n    if (state.flipSoon === true) {\n      return false;\n    }\n\n    dispatch({\n      type: \"FLIP_CARD\",\n      data: { id: card.id, matchId: card.matchId },\n    });\n  };\n\n  const cards = Object.values(state.cardsByIds);\n\n  return (\n    <React.Fragment>\n      <GlobalStyle />\n\n      <AppShell>\n        <Flex>\n          <Intro>\n            <h1>Memory game</h1>\n            <p>Support of themes, difficulty and cats.</p>\n          </Intro>\n        </Flex>\n\n        <Flex>\n          <Board\n            cards={cards}\n            onCardFlip={flipCard}\n            flipSoon={state.flipSoon}\n            flipCardsBack={flipCardsBack}\n          />\n        </Flex>\n\n        {state.allFlipped ? (\n          <Result\n            data={{\n              roundDuration: state.roundDuration,\n              moves: state.moves,\n              cardsAmount: config.size,\n            }}\n            onClose={() => restartGame()}\n          />\n        ) : null}\n\n        <Flex>\n          <Intro>\n            <p>\n              <strong>Themes support</strong>\n            </p>\n            <p>\n              Add new folder with cards tiles - and you will have set of cards\n              to play: based on available unique tiles game create set of pairs\n              of cards\n            </p>\n            <br />\n            <p>\n              <strong>Difficulties switcher</strong>\n            </p>\n            <p>\n              Amount of cards on the board and amount of unique pieces are in\n              the config, and with updating two numbers game could vary in\n              difficulty and adjust matching logic.\n            </p>\n          </Intro>\n        </Flex>\n      </AppShell>\n    </React.Fragment>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}